\documentclass[12pt,reqno]{amsart}

\usepackage{amsthm,amsmath,amssymb}
\usepackage{mathtools}
\usepackage{proof}
\usepackage{xcolor}
\usepackage[T1]{fontenc}
\usepackage{courier}
\usepackage{hyperref}
\hypersetup{
    hidelinks=true
}
\usepackage{listings}
\lstset{basicstyle=\ttfamily\small, columns=fullflexible, language=Lisp, morekeywords={define, lambda, if, car, cdr, zero, eopl}, keywordstyle=\bfseries\color{blue!40!black}}
\newcommand{\code}[1]{\texttt{#1}}


\begin{document}

\begin{center}
\large\textbf{Problem Set 1 \\ COMP301 Fall 2019} \\
\normalsize\textbf{03.10.2019 17:30 - 18:45} \\
\end{center}

\vspace{7.5mm}

\textbf{Problem 1}\footnote{EOPL p.16 Exercise 1.1}: Write inductive definitions of the following sets. Write each definition in all 3 styles (top-down, bottom-up, rules of inference). Using your rules, show the derivation of some sample elements of each set.
\begin{enumerate}
	\item $\{3n+2 | n \in \mathbb{N}\}$
	\item $\{2n + 3m + 1 | n, m \in \mathbb{N}\}$
	\item $\{(n, 2n+1) | n \in \mathbb{N}\}$
	\item $\{(n, n^2) | n \in \mathbb{N} \}$ Do not mention squaring in your rules! As a hint, remember that $(n+1)^2 = n^2 + 2n + 1$
\end{enumerate}

\vspace{7.5mm}

\textbf{Problem 2}\footnote{EOPL p.16 Exercise 1.4}: Write a derivation from \textit{List-of-Int} to $(-7 \ .\  (3 \ .\  (14 \ .\  ())))$.

\vspace{7.5mm}

\textbf{Problem 3}\footnote{EOPL p.16 Exercise 1.6}: If we reversed the order of the tests in the \code{nth-element}, what would go wrong? \\
\textbf{nth-element}: $List \times Int \xrightarrow{} SchemeVal$ \\
\textbf{Usage}: \code{(nth-element lst n)} = the \code{n}$^\text{th}$ element of \code{lst}
\begin{lstlisting}
(define nth-element
    (lambda (lst n)
        (if (null? lst)
            (report-list-too-short n)
            (if (zero? n)
                (car lst)
                (nth-element (cdr lst) (- n 1))))))
                
(define report-list-too-short
    (lambda (n)
        (eopl:error 'nth-element
            ''List too short by !~s elements.~%'' (+ n 1))))
\end{lstlisting}

\vspace{7.5mm}

\textbf{Problem 4}\footnote{EOPL p.22 Exercise 1.12}: Eliminate the one call to \code{subst-in-s-exp} in \code{subst} by replacing it by its definition and simplifying the resulting procedure. The result will be a version of \code{subst} that does not need \code{subst-in-s-exp}. This technique is called inlining, and is used by compilers for optimization.

\vspace{7.5mm}

\textbf{Problem 5}\footnote{EOPL p.27 Exercise 1.21}: Implement \code{product}: the expression \code{(product sos1 sos2)} where \code{sos1} and \code{sos2} are each a list of symbols without repetitions, returns a list of 2-lists that represent the Cartesian product of \code{sos1} and \code{sos2}. The 2-lists may appear in any order.
\begin{lstlisting}
$ (product (a b c) (x y))
((a x) (a y) (b x) (b y) (c x) (c y))
\end{lstlisting}

\vspace{7.5mm}

\textbf{Problem 6}\footnote{EOPL p.28 Exercise 1.26}: \code{(up lst)} removes a pair of parantheses from each top level element of \code{lst}. If a top-level is not a list, it is included in the result as is. The value of \code{(up (down lst))} is equivalent to \code{lst}, but \code{(down (up lst))} is not necessarily \code{lst}. (\code{down} appears in exercise 1.17)
\begin{lstlisting}
$ (up ((1 2) (3 4)))
(1 2 3 4)
$ (up ((x (y) z)))
(x (y) z)
\end{lstlisting}
\textit{Exercise 1.17:}
\code{(down lst)} wraps parantheses around each top-level element of \code{lst}.
\begin{lstlisting}
$ (down (1 2 3))
((1) (2) (3))
$ (down ((a) (fine) (idea))
(((a)) ((fine)) ((idea)))
$ (down (a (more (complicated)) object))
((a) ((more (complicated))) (object))
\end{lstlisting}

\newpage
\textbf{Problem 7}\footnote{EOPL p.30 Exercise 1.34}: Write a procedure path that takes an integer $n$ and a binary search tree \textit{bst} (see EOPL p.10) that contains the integer $n$, returns a list of lefts and rights showing how to find the node containing $n$. If $n$ is found at the root, it returns the empty list.
\begin{lstlisting}
$ (path 17 (14 
	    (7   ()    (12 () ()))
	    (26 
	        (20 
	            (17 () ())
	            ())
	        (31 () () ))))
(right left left)
\end{lstlisting}
\textbf{Hint}: The grammar of BST is: \\ $\textit{Binary-search-tree} ::= () \  | \  (\textit{Int Binary-search-tree Binary-search-tree})$

\vspace{7.5mm}

\textbf{Problem 8}\footnote{EOPL p.30 Exercise 1.36}: Write a procedure \code{g} such that \code{number-elements} from EOPL page 23 could be defined as:
\begin{lstlisting}
(define number-elements
    (lambda (lst)
        (if (null? lst) ()
            (g (list 0 (car lst)) (number-elements (cdr lst))))))
\end{lstlisting}
\textbf{Hint}: \code{number-elements-from} and \code{number-elements} are given in EOPL page 23. \\
\textbf{Usage:} \code{(number-elements-from (v0 v1 v2 ...) n) \\ = ((n v0) (n+1 v2) (n+2 v2) ... )}
\begin{lstlisting}
(define number-elements-from 
    (lambda (lst n)
        (if (null? lst) ()
            (cons 
                (list n (car lst))
                (number-elements-from (cdr lst) (+ n 1))))))

(define number-elements
    (lambda (lst)
        (number-elements-from lst 0)))
\end{lstlisting}
\textbf{Don't forget the attendance!} Also, download the program from \url{https://download.racket-lang.org/}
\end{document}