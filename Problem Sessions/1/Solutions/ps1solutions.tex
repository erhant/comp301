\documentclass[12pt,reqno]{amsart}

\usepackage{amsthm,amsmath,amssymb}
\usepackage{mathtools}
\usepackage{proof}
\usepackage{xcolor}
\usepackage{listings}
\lstset{basicstyle=\ttfamily\small, columns=fullflexible, language=Lisp, morekeywords={define, lambda, if, car, cdr, zero}, keywordstyle=\bfseries\color{blue!40!black}}
\newcommand{\code}[1]{\texttt{#1}}


\begin{document}

\begin{center}
\large\textbf{Problem Set 1 Solutions\\ COMP301 Fall 2019} \\
\normalsize\textbf{03.10.2019 17:30 - 18:45} \\
\end{center}


\textbf{Problem 1}\footnote{EOPL p.16 Exercise 1.1}:
\begin{enumerate}
	\item $\{3n+2 | n \in \mathbb{N}\}$
	\begin{enumerate} \item Top-down\\
	$n \in S$ if $n = 2$ or \\
	$n - 3 \in S$ 
	\item Bottom-up\\
	$S$ is the smallest set satisfying the two properties: \\$2 \in S$ and \\
	if $n \in S$ then $n+3 \in S$
	\item Rules of Inference \\
	 \infer{2 \in S}{} \hspace{2mm}
	 \infer{n+3 \in S}{n \in S}
	\end{enumerate}
	\item $\{2n + 3m + 1 | n, m \in \mathbb{N}\}$
	\begin{enumerate} \item Top-down\\
	$n \in S$ if $n = 1$ or \\
	$n - 2 \in S$ or \\
	$n - 3 \in S$.
	\item Bottom-up\\
	$S$ is the smallest set satisfying the two properties:\\$1 \in S$ and \\ 
	if $n \in S$ then $n+2 \in S$ or $n+3 \in S$
	\item Rules of Inference\\
	\infer{1\in S}{} \hspace{2mm}
	\infer{n+2 \in S}{n \in S} \hspace{2mm}
	\infer{n + 3 \in S}{n \in S}
	\end{enumerate}
	\item $\{(n, 2n+1) | n \in \mathbb{N}\}$
	\begin{enumerate} \item Top-down\\
	$(m, n) \in S$ if $m=0$ and $n=1$ or \\
	$(m-1, n-2) \in S$
	\item Bottom-up\\
	$S$ is the smallest set satisfying the two properties: \\$(0, 1) \in S$ and \\ 
	if $(m, n) \in S$ then $(m+1, n+2) \in S$
	\item Rules of Inference\\
	\infer{(0,1) \in S}{} \hspace{2mm} 
	\infer{(m+1, n+2) \in S}{(m,n) \in S}
	\end{enumerate}
	\item $\{(n, n^2) | n \in \mathbb{N} \}$
	\begin{enumerate} \item Top-down\\
	$(m, n) \in S$ if $m=0$ and $n=0$ or \\
	$(m-1, n-2m+1) \in S$
	\item Bottom-up\\
	$S$ is the smallest set satisfying the two properties: $(0, 0) \in S$ and \\ 
	if $(m, n) \in S$ then $(m+1, n+2m+1) \in S$
	\item Rules of Inference\\
	\infer{(0,0) \in S}{} \hspace{2mm} 
	\infer{(m+1, n+2m+1) \in S}{(m,n) \in S}
	\end{enumerate}
	
\end{enumerate}

\vspace{7.5mm}
\textbf{Problem 2}\footnote{EOPL p.16 Exercise 1.4}: \\
\code{List-of-Int} \\
$\xrightarrow{}$\code{(Int . List-of-Int)} \\
$\xrightarrow{}$\code{(Int . (Int . List-of-Int))} \\
$\xrightarrow{}$\code{(Int . (Int . (Int . List-of-Int)))} \\
$\xrightarrow{}$\code{(-7 . (Int . (Int . List-of-Int)))} \\
$\xrightarrow{}$\code{(-7 . (3 . (Int . List-of-Int)))} \\
$\xrightarrow{}$\code{(-7 . (3 . (14 . List-of-Int)))} \\
$\xrightarrow{}$\code{(-7 . (3 . (14 . ())))} 

\vspace{7.5mm}
\textbf{Problem 3}\footnote{EOPL p.16 Exercise 1.6}: 
If we dont check \code{(null? lst)} and we do \code{(car lst)}, it is possible that \code{car} might be applied to an empty list, which causes an error.

\newpage
\textbf{Problem 4}\footnote{EOPL p.22 Exercise 1.12}:
Refer to \textit{ps1solutions.scm}.
\begin{lstlisting}
;Function:Subst symbol x symbol x s-list -> s-list
(define subst
  (lambda (new old slist)
    (if (null? slist)
        '()
        (cons
         ((lambda (new old sexp)
            (if (symbol? sexp)
                (if (eqv? sexp old) new sexp)
                (subst new old sexp))) new old (car slist))
         (subst new old (cdr slist))))))
\end{lstlisting}

\newpage
\textbf{Problem 5}\footnote{EOPL p.27 Exercise 1.21}:
Refer to \textit{ps1solutions.scm}.
\begin{lstlisting}
;Function:Product list x list -> list
(define product
  (lambda (sos1 sos2)
    (prod-help sos1 sos2 sos2)))

;Function:Prod-help list x list x list -> list
(define prod-help
  (lambda (sos1 sos2 temp)
    (cond
      ((null? sos1) '())
      ((null? temp) (prod-help (cdr sos1) sos2 sos2))
      (else (cons (list (car sos1) (car temp)) 
                  (prod-help sos1 sos2 (cdr temp)))))))
\end{lstlisting}

\newpage
\textbf{Problem 6}\footnote{EOPL p.28 Exercise 1.26}:
Refer to \textit{ps1solutions.scm}.
\begin{lstlisting}
;Function:Up list -> list
(define up 
  (lambda (lst)
    (cond
      ((null? lst) '())
      ((pair? (car lst)) (append (car lst) (up (cdr lst))))
      (else (cons (car lst) (up (cdr lst)))))))

;Function:Down list -> list
(define down
  (lambda (lst)
    (cond
      ((null? lst) '())
      (else (cons (list (car lst)) (down (cdr lst)))))))
\end{lstlisting}

\newpage
\textbf{Problem 7}\footnote{EOPL p.30 Exercise 1.34}:
Refer to \textit{ps1solutions.scm}.
\begin{lstlisting}
;Function:Path Sybmol x binary-tree(list) -> list
(define path
  (lambda (n bin-tree)
    (path-help n bin-tree '())))

;Function:Path Sybmol x binary-tree(list) x list -> list
(define path-help
  (lambda (n bin-tree waylst)
    (cond
      ((null? bin-tree) '())
      ((eqv? n (car bin-tree)) waylst)
      (else (append (path-help n (cadr bin-tree) (append waylst '(left))) 
                    (path-help n (caddr bin-tree) (append waylst '(right))))))))
\end{lstlisting}

\newpage
\textbf{Problem 8}\footnote{EOPL p.30 Exercise 1.36}: 
Refer to \textit{ps1solutions.scm}.
\begin{lstlisting}
;Function:G list x list -> list
(define g
  (lambda (lst1 lst2)
        (cons lst1 (map (lambda (x) (list (+ 1 (car x)) (cadr x))) lst2))))
        
;Function:Number-elements list -> list
(define number-elements
  (lambda (lst)
    (if (null? lst) '()
        (g (list 0 (car lst)) (number-elements (cdr lst))))))
\end{lstlisting}

\end{document}