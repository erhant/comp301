\documentclass[12pt,reqno]{amsart}

\usepackage{amsthm,amsmath,amssymb}
\usepackage{mathtools}
\usepackage{geometry}
\usepackage{proof}
\usepackage{xcolor}
\usepackage{graphicx}
\usepackage[T1]{fontenc}
\usepackage{courier}
\usepackage{hyperref}
\hypersetup{
    hidelinks=true
}
\usepackage{listings}
\lstset{basicstyle=\ttfamily\small, columns=fullflexible, language=Lisp, morekeywords={define, lambda, if, car, cdr, zero, eopl, proc, letrec, in, then, else}, keywordstyle=\bfseries\color{blue!40!black}}
\newcommand{\code}[1]{\texttt{#1}}
\graphicspath{ {./} }
\geometry{
 a4paper,
 total={170mm,257mm},
 left=25mm,
 top=20mm,
 }


\begin{document}
\thispagestyle{empty}
\begin{center}
\large\textbf{Problem Set 6 \\ COMP301 Fall 2019} \\
\normalsize\textbf{14.11.2019 17:30 - 18:45} \\
\end{center}

\vspace{7.5mm}

\subsection*{Read me first!} Please download the \textit{Codes} file. In the scheme codes, you will see some hints regarding where to modify. You will use DrRacket. We have also edited the \code{tests.rkt} for each of them so that if you solve the problem, running \code{tests.rkt} should have no errors. You can also write your own program in \code{let}, \code{letrec} or \code{proc} by writing your code in a string and run it from the console of the respective \code{tests.rkt} like this:
\begin{lstlisting}
(display (run ''your code here''))
\end{lstlisting}
Make sure you run the file itself to update the definitions before running your code from console. Regarding problem 3, just write the answer to a text file and save itr. As for your submission, you will submit your modified code and the text file for problem 3 in a zip folder.

\vspace{7.5mm}

\textbf{Problem 1}\footnote{EOPL p.74 Exercise 3.12}: Extend the \code{let} language so that it can use \code{cond} expression. Use the grammar below:
$$
Expression :== \text{\code{cond }} \{Expression ==> Expression\}^* \text{\code{ end}}
$$
In this expression, tests, which are the expressions on the left-hand sides of the $==>$â€™s, are evaluated in order until one of them returns a true value. When one of the tests returns true, the value of the entire expression is the value of the corresponding right-hand expression. If none of the tests succeeds, the expression should report an error.

\vspace{7.5mm}

\textbf{Problem 2}\footnote{EOPL p.80-81 Exercise 3.21}: Extend the \code{proc} language so that it includes procedures with multiple arguments and calls with multiple operands, as suggested by the grammar below:
$$
Expression :== \text{\code{proc }} (\{Identifier\}^{*(,)}) \text{ } Expression
$$
$$
Expression :== (Expression \text{ } \{Expression\}^*)
$$

\vspace{7.5mm}

\textit{Continue to the next page for 2 more questions.}
\newpage
\textbf{Problem 3}\footnote{EOPL p.81 Exercise 3.25}: The tricks of the previous exercises in the book can be generalized to show that we can define any recursive procedure in \code{proc} language, though it is a bit trickier than it would have been in \code{letrec}. Consider the following bit of code:
\begin{lstlisting}
let makerec = proc (f)
    let d = proc (x)
        proc (z) ((f (x x)) z)
    in proc (n) ((f (d d)) n)
in let maketimes4	= proc (f) proc (x)
        	          if zero?(x) then 0 else -((f -(x,1)), -4)
    in let times4 = (makerec maketimes4)
        in (times4 3)            			 
\end{lstlisting}
Show that this returns 12. Write your answer in \code{problem3.txt}.

\vspace{7.5mm}

\textbf{Problem 4}\footnote{EOPL p.101 Exercise 3.38}: Implement \code{cond} from Problem 1 for the lexical addressing language (the language in the folder \code{problem4-lexaddr-lang}). You will almost do the same modifications you did for Problem 1, but for this one you will also have to modify the code in \code{translator.rkt}.

\end{document}