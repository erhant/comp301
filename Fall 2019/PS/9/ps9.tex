\documentclass[12pt,reqno]{amsart}

\usepackage{amsthm,amsmath,amssymb}
\usepackage{mathtools}
\usepackage{geometry}
\usepackage{proof}
\usepackage{xcolor}
\usepackage{graphicx}
\usepackage[T1]{fontenc}
\usepackage{courier}
\usepackage{hyperref}
\hypersetup{
    hidelinks=true
}
\usepackage{listings}
\lstset{basicstyle=\ttfamily\small, columns=fullflexible, language=Lisp, morekeywords={define, lambda, if, car, cdr, zero, eopl, proc, letrec, in, then, else}, keywordstyle=\bfseries\color{blue!40!black}}
\newcommand{\code}[1]{\texttt{#1}}
\graphicspath{ {./} }
\geometry{
 a4paper,
 total={170mm,257mm},
 left=25mm,
 top=20mm,
 }


\begin{document}
\thispagestyle{empty}
\begin{center}
\large\textbf{Problem Set 9 \\ COMP301 Fall 2019} \\
\normalsize\textbf{12.12.2019 17:30 - 18:45} \\
\end{center}

\vspace{7.5mm}


\textbf{Problem 1}\footnote{EOPL p.84-85 Exercise 3.32}: Extend the \code{letrec} language to allow the declaration of any number of mututally recursive unary procedures, for example:
\begin{lstlisting}
letrec
   even(x) = if zero?(x) then 1 else (odd -(x,1))
   odd(x) = if zero?(x) then 0 else (even -(x,1))
in (odd 13)
\end{lstlisting}
evaluates to 1 because 13 is an odd number. (This question appeared in an earlier PS, but was left unsolved by majority due to time limit.)

\vspace{7.5mm}

\textbf{Problem 2}\footnote{EOPL p.122 Exercise 4.21}: It is suggested in the EOPL book: the use of assignment to make a program more modular by allowing one procedure to communicate information to a distant procedure without requiring intermediate procedures to be aware of it. Very often such an assignment should only be temporary, lasting for the execution of a procedure call. Add to the language a facility for dynamic assignment (also called fluid binding) to accomplish this. Use the production:
$$
Expression ::= \text{\code{setdynamic}}\text{ }Identifier\text{ } = \text{ }Expression \text{ }\text{\code{during}} \text{ }Expression
$$
$$
 \text{\code{setdynamic-exp}} \text{ }(\text{\textit{\code{var}}}\text{ } \text{\textit{\code{exp1}}}\text{ } \text{\textit{\code{body}}})
$$
The effect of the \code{setdynamic} expression is to assign temporarily the value of \textit{\code{exp1}} to \textit{\code{var}}, evaluate \textit{\code{body}}, reassign \textit{\code{var}} to its original value, and return the value of \textit{\code{body}}. The variable \textit{\code{var}} must already be bound. For example:
\begin{lstlisting}
let x = 11
in let p = proc (y) -(y,x)
    in -(setdynamic x = 17 during (p 22), (p 13))
\end{lstlisting}
In this code,the value of \code{x} which is in \code{p}, is set to 17 in the call \code{(p 22)} but is reset to 11 in \code{(p 13)}, so the value of the expression is $5-2 = 3$.

\vspace{7.5mm}

\textbf{Problem 3}\footnote{EOPL p.133  Exercise 4.37}: \code{Call-by-value-result} is a variation on \code{call-by-reference}. In \code{call-by-value-result}, the actual parameter must be a variable. When a parameter is passed, the formal parameter is bound to a new reference initialized to the value of the actual parameter, just as in \code{call-by-value}. The procedure body is then executed normally. When the procedure body returns, however, the value in the new reference is copied back into the reference denoted by the actual parameter. This may be more efficient than \code{call-by-reference} because it can improve memory locality. Implement \code{call-by-value-result} by modifying \code{call-by-reference}. In the actual exercise in the book, you are also asked to come up with a code that gives different results for each case. We have written that for you, check the bottom of the file. You will also refer to that to check if your program is correct.
\textbf{NOTE:} We have put all necessary modules in a single file for this problem. This is done in order to test DMOJ at some point too.
\end{document}